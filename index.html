<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Visual Graph Traversal</title>
    <link rel="stylesheet" href="style.css">
  </head>
  
  <body>
    <div class="toc">
      <ul>
        <li><a class="top" href="#top">Top &uarr;</a></li>
        <li><a href="#bfs" title="Breath-first Search">BFS</a></li>
        <li><a href="#cc" title="Connected Components Labeling with BFS">Components</a></li>
        <li><a href="#dfs" title="Depth-first Search">DFS</a></li>
        <li><a href="#cycle" title="Cycle Detection with DFS">Cycle</a></li>
        <li><a href="#topo" title="Topological Sort">Toposort</a></li>
        <li><a href="#scc" title="Strongly Connected Components">Strong</a></li>
        <li><a href="#dijkstra" title="Dijkstra Single-Source Shortest Paths">Dijkstra</a></li>
        <li><a href="#prim" title="Prim Minimum Spanning Tree">Prim</a></li>

      </ul>
    </div>


    <h1>Visual Graph Traversal</h1>

    <h3>Cheng Yichao / April, 2013</h3>


    <p class="sidenote"><img src="./img/eda.jpg"></p>
    <p>In Computer Science, <a href="http://en.wikipedia.org/wiki/Graph_traversal">graph traversal</a> is a set of problems of visiting all the nodes(or vertices in a graph in a particular manner, updating and/or checking their attributes along the way. </p>



    <p>Graph is a very common representation in many applications. Graph traversal algorithms provide crucial tools in many computational fields ranging from genomics to electronic design automation(EDA) to social network analysis.</p>




    <p>Generally, graph has more complicated structure than array, list, and tree. The representation of graph could either be adjacency matrix or adjacency list and different data structures are preferred in different situation. For example, adjacency lists are often used to represent sparse graph due to less edge storage. But in this article we will pay more attention to the topology of a graph instead of the underlayer representation. The visualiztions are intended to help one understand the process of exploration and how the values are updated during traverse.</p>


    <p>We tailored <a href="http://getspringy.com/">springy.js</a>, a library using directed forced algorithm to layout graph, to visualize all the algorithms here. The <a href="https://github.com/onesuper/Medusa">codes</a> are  written in JavaScript.</p>



    <h2 id="bfs">Breath-first Search</h2>


    <p><a href="http://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</a>(BFS for short) is a classic  graph algorithm. Given a graph <i>G=(V, E)</i>, and a source vertex <i>s</i>, BFS produces a <b>breath-first tree</b> with the root <i>s</i> and all reachable vertices. The traditional BFS algorithm keeps exploring the tree until each reachable vertex has been assigned a <strong>level</strong> which tells the <b><i>height</i></b> in the tree, or the minimum hoops from the root. (In some cases, algorithm will simply preserve the pointer referencing to the predecessor.)</p>


    <p>The main idea of BFS is traversing all the nodes within a graph level by level. All the vertices in level n are visited before the traversal of level n+1 starts. Usually, a <strong>queue</strong>* is used in a serial BFS implementation, to keep the order of nodes being visited.</p>


    <p>Let's see a live example. Initially, only the <i>root</i>(node 0) is in the queue(marked pink). In the first iteration, we dequeue the first element in the queue(node 0) and visit it, thus marking node 0 gray. Meanwhile, we find all the nodes adjacent to 0(node 1, 2, 3) and put them onto queue, since they have never been dicovered. In the second iteration, node 1 is dequeued and visited. At the same time, one of its neighbours, node 4, is appended to the queue. However, the other neighbour(node 0) is ignored, since we have visited it before. As you can see, the final result of BFS is a tree.</p>


    <iframe src="./bfs/index.html" scrolling="no" frameborder="0" width="780" height="560"></iframe>


    <p>It's not hard to see the time complexity of BFS is <i>O(V+E)</i> since all the vertices and edges in the graph are marked or colored only once. </p>
    

    <p><strong>Pseudocode:</strong></p>
    <code>
      <pre>
        // start from root
        Q.enqueue(root);
        root.color = pink;

        while (!Q.empty()) {
            u = Q.dequeue();
            u.color = black;
            foreach (v in u.neighbours()) {
                if (v.color==white) {
                    v.color = pink;
                    Q.enqueue(v);
                }
            }
        }</pre></code>


     <h2 id="cc">Connected Components Labeling with BFS</h2>

     <p>Breath-first search can be used to find <b>connected components</b> in a graph. <a href="http://en.wikipedia.org/wiki/Connected_component_(graph_theory)">Connected component</a> is a subgraph of <i>G=(V, E)</i>, in which all vertices can reach another. The connected components labeling problem is to find the different connected components in a graph.   </p>

    <p>The alorithm continue starting a BFS from an unvisited node until all nodes in the graph have been visited. In our example, breath-first search are launched twice. The first BFS starts from vertex 0 as root and the second one begins at 4. In each iteration of BFS, every vertex's ID value is updated to the ID value of its predecessor. Finally, All the vertices in a connected component are labeled with the same ID, which is the ID of BFS tree root.</p>


     <iframe src="./cc/index.html" scrolling="no" frameborder="0" width="780" height="560"></iframe>

  



    <p><strong>Pseudocode:</strong></p>
     <code>
      <pre>
        foreach (node in G) {
            if(!node.visited)
                 BFS(node);
        }</pre></code>


    <h2 id="dfs">Depth-first Search</h2>


    <p>Breath-first search expands the nodes of the same level by one hop. On the contrary, <a href="http://en.wikipedia.org/wiki/Depth-first_search">depth-first search</a>(DFS) explores as far as possible along each branch before backtracking. Exactly, DFS keep discovering entering the first child node of search tree that appears until it encounter a node that has no children. Then DFS visits the node and backtracks, returning to the most recent decovered node.</p>

    <p>That is, every vertex in the graph will be went</p>

    <p>DFS can be wrote in both recursive and non-recursive(iterative) way. Here we only introduce the iterative version. The algorithm uses a FILO stack to record the decovered nodes in the halfway.</p>

    <p>In the following example, we start a DFS on node 0 as the root. In the first iteration, we dicover node 1 and node 2 and append them to the stack. In the second iteration, we enter node 1, the first child of node 0, and dicover 5 and 6. Then we enter node 5, the first child of node 1, and find node 4, who has no children. Then we visit node 4 and "backtrack" to node 5, which has no unvisited children. Then we "backtrack" to node 1 and enter its second neighbour node 6, thus visiting it...</p>



    <iframe src="./dfs/index.html" scrolling="no" frameborder="0" width="780" height="560"></iframe>



    <p><strong>Pseudocode:</strong></p>
    <code>
      <pre>
        // start from root
        S.push(root);
        root.color = pink;

        while (!S.empty()) {
            
            u = S.top();
            flag = 0;    // has discovered neighbour?

            foreach (v in u.neighbours()) {
                if (v.color == white) {
                    v.color = pink;
                    S.push(v);
                    flag = 1;
                }
            }
            if (flag == 0) {
                u.color = black;
                u.pop();
            }
        }</pre></code>


    


    <h2 id="cycle">Cycle Detection with DFS</h2>

    <p>It's easy to use depth-first search to check whether or not an undirected graph contains a <a href="http://en.wikipedia.org/wiki/Cycle_(graph_theory)">cycle</a>.</p>

    <p>If we find node A's neighbour B visited, either B is A's predecessor or there exists another path from root to B which means the graph has a cycle. </p>

    <p>In our example, node 4 dicovers node 1 whose predecessor is node 2. We call 4->1 "back edge".</p>

    <iframe src="./cycle/index.html" scrolling="no" frameborder="0" width="780" height="560"></iframe>


    <p><strong>Pseudocode:</strong></p>
    <code>
      <pre>
        // start from root
        Q.push(root);
        root.color = pink;

        while (!Q.empty()) {
            u = Q.pop();
            u.color = black;
            foreach (v in u.neighbours()) {
                if (v.color == white) {
                    v.color = pink;
                    Q.push(v);
                } else if(u.prev != v)
                    alert("cycle detected!");
                }
            }
        }</pre></code>




    <h2 id="topo">Topological Sort with DFS</h2>


    <p>A diagraph is <strong>acyclic</strong> if it has no cycles. Such graph is often referred to as a  <a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph</a>, or <b>DAG</b> for short. DAGs can be used to describe the dependencies between tasks. If there is a directed edge in the graph from A to B, that means task A should be performed before task B. In a DAG, if task A depends on B and B depends on C, task A must be depending on C. A reasonable schedule strategy is just a valid sequece for the tasks. </p>

    <p>Say we have 4 instructions to perform. I<sub>1</sub> depends on I<sub>2</sub> and I<sub>3</sub> depends on I<sub>4</sub>. But there's no dependencies between (I<sub>1</sub>, I<sub>3</sub>), (I<sub>1</sub>, I<sub>4</sub>), (I<sub>2</sub>, I<sub>3</sub>) and (I<sub>2</sub>, I<sub>4</sub>). So an instruction sequence of I<sub>2</sub>, I<sub>4</sub>, I<sub>1</sub>, I<sub>3</sub> is acceptable while I<sub>2</sub>, I<sub>3</sub>, I<sub>4</sub>, I<sub>1</sub> is a wrong order.</p>

    <p><a href="http://en.wikipedia.org/wiki/Topological_sorting">Topological sort</a> is the process to find a valid order for a given DAG. The most straightforward way to construct a topological ordering of a DAG is using DFS, which requires linear time. </p>

    <p>The following interesting example is borrowed from CLRS. The DAG describes the dependencies between the tasks Professor Bumstead perform in the morning.</p>
  


    <iframe src="./topo/index.html" scrolling="no" frameborder="0" width="780" height="560"></iframe>
    

    <h2 id="scc">Strongly Connected Components</h2>




    <p class="sidenote"><img src="./img/strong.jpg" /></p>
    <p>Given a directed graph <i>G=(V, E)</i>. a <a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/strongComponent.htm">strongly connected component</a>(SCC) of G is a maximal <b>set of vertices</b>, such that for all (u, v) in that set, both u and v are reachable from each other. In other words, two vertices are in the same components if and only if they are reachable from each other.</p>


    <p><a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms">CLRS</a> uses the transpose of G(G<sup>T</sup>) to find the SCC. G<sup>T</sup> is G with all edges reversed. The algorithm is based the observation that the graph G and G<sup>T</sup> have the same SCC.</p>



    <h2 id="dijkstra">Dijkstra Single-Source Shortest Paths</h2>



    <p class="sidenote"><img src="./img/road.jpg"></p>
    <p>The Single-Source Shortest Paths(SSSP for short) is the problem of computing the shortest path distance from a root vertex <i>r</i> to each vertex in a weighed graph.</p>



    <p>A good anology is when your driving a car among cities, a call to SSSP subroutine can help you find the shortcut to each city. That's why the algorithm is often used in GPS and network routing.</p>




    <p>If the edge weights are all non-negative, then the SSSP problem can be solved with <b>Dijkstra</b> algorithm. Otherwise, <b>Bellman-Ford</b> algorithm can be used instead.</p>


    <p>Dijkstra's SSSP explores the graph with a greedy method. In each iteration, the algorithm visits a node with the so-far-smallest distance from root among all the nodes in the graph.</p> 


    <p class="sidenote">dist(1) is shorthand for "distance from root to node 1"</p>

    <p>Assume the root is node 0. To start, make the distance to the other node in the graph with infinity(100,000 is large enough in our case). In the first iteration, node 0 is visited. Meanwhile the dist(1)*  is updated to 41 and dist(5) is updated to 29. They are both unreachable before node 0 is visited. In the second iteration, we visit node 5 since it has the smallest distance from root, updating dist(4) to 50, which is the cost if we manage to arrive at node 5(cost 29) first and pay a travel to node 4(cost 21)... After several iterations, we arrive at node 2. This time we are not going to update dist(3), because it costs 132 if we come from 2(cost 50) coming from 3(cost 82) but it only costs 86 if we manage to reach 4(cost 50) and then go to 3(cost 36).</p>


    <iframe src="./sssp/index.html" scrolling="no" frameborder="0" width="780" height="560"></iframe>


    <p>During the exploration, a set Q is used to maintain the unvisited nodes, which provides an operation to extract the minimum. The time complexity of Dijkstra algorithm is relevant to the implementation of Q. If Q is a linked list or array, then finding minium from Q is a linear search through all nodes in Q, which requires <i>O(V)</i>. But if we use a <a href="http://en.wikipedia.org/wiki/Fibonacci_heap">Fibonacci heap</a> as a priority queue, the search time can be reduced to <i>O(logV)</i>.</p>


    <p>Like breath-first search, Dijkstra SSSP produces a tree(shortest-path tree) from the root.</p>

    <p><strong>pseudocode</strong></p>

    <code><pre>
        // intialize node attributes
        foreach (v in G) {
            v.dist = infinity;
            v.pre = undefined;
        }

        // all nodes in Q
        Q = G.all();
        G.nodes[0].dist = 0;
        
        while(!Q.empty()) {
            u = Q.dequeue();   //u has the smallest distance in dist[]
            foreach (v in u.neighbours()) {                
                // update v's dist, if find a shorter path
                if (u.dist + u.distance_to(v) < v.dist) {
                    v.dist = alt;  
                    v.pre = u;
                    Q.reorder();   // since distance changes
                }
            }
        }</pre></code>



     <h2 id="prim">Prim Minimum Spanning Tree</h2>
     <iframe src="./mst/index.html" scrolling="no" frameborder="0" width="780" height="560"></iframe>


     <h2 id="fw">Floyd-Warshall All-pairs shortest Path</h2>

     <iframe src="./apsp/index.html" scrolling="no" frameborder="0" width="780" height="560"></iframe>






    <br>
    <br>
    <a href="https://twitter.com/share" class="twitter-share-button" data-url="http://chengyichao.info/visual-graph-traversal" data-via="chengyichao" data-count="none">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>



  </body>


  


  

</html>
